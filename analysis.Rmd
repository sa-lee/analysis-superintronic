---
title: "Exploring intron signal in RNA-seq data using coverage estimation"
author: "Stuart Lee, Charity Law"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
                      fig.align = "center",
                      comment = "#>", 
                      message = FALSE,
                      warning = FALSE,
                      fig.path = here::here("figures/"),
                      cache.path = here::here("cache/")
                      )

# pre load libraries
suppressPackageStartupMessages(library(plyranges))
suppressPackageStartupMessages(library(superintronic))

# useful functions
hex <- function(data, mapping, ...) {
  ggplot2::ggplot(data = data, mapping = mapping) + 
    ggplot2::geom_hex(...) +
    # ggplot2::geom_point(data = filter(data, gene_id %in% gene_paper), colour = "red") +
    ggplot2::scale_fill_viridis_c(direction = -1)
}

save_plot <- function(.x, .y) {
  target <- filter(parts_sub, gene_id == !!.y$gene_id)
  fname <- paste0(target$gene_name, "_coverage_plot.pdf")
  fname <- here::here("figures", fname)
  p <- view_coverage(cvg_over_features, target, facets = "Kit")
  print(p)
  ggplot2::ggsave(fname, p, dpi = "retina")
} 

save_plot_isr <- function(.x, .y) {
  target <- filter(parts, gene_id == !!.y$gene_id)
  cvg_sub <- join_parts(cvg, target)
  fname <- paste0(target$gene_name, "_isr_coverage_plot.pdf")
  fname <- here::here("figures", fname)
  p <- view_coverage(cvg_sub, target, facets = "Kit")
  print(p)
  ggplot2::ggsave(fname, p, dpi = "retina")
}
```

# Introduction

This report looks finding intron retention genes using simple summary 
statistics and visualisations using `superintronic`. We also compare the results to those
obtained using `IsoFormSwitchAnalyzeR`.

## Data

We will use data from 6 samples from the human cell line mixture RNA-seq
data. There are three biological replicates across two library preparation kits,
a polyA kit and a total RNA kit. The BAM files have been previously aligned
with subread using the hg20 reference genome. 

```{r prepare-design}
design <- read.table(
  here::here("data-raw", "targets.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
) %>% 
  S4Vectors::DataFrame() %>% 
  transform(
    File = S4Vectors::Rle(here::here("data-raw", sub("\\.", "-", File)))
  ) %>% 
  BiocGenerics::subset(Replicate %in% c("R1", "R2", "R3") & Mixture == 0,
                       select = c(File, Mixture, Replicate, Kit)) %>%  
  S4Vectors::transform(
    CellLine = "HCC287",
    Kit = S4Vectors::Rle(ifelse(Kit == "mRNA", "polyA", "total-RNA"))
  ) %>% 
  S4Vectors::transform(
    Sample =  paste(Replicate, CellLine, Kit, sep = "_")
  )
design
```


## `superintronic` analysis

A superintronic analysis consists of three steps:
1. Preparing the annotation and extract exonic/intronic parts
2. Computing coverage over regions of interest
3.


### Preparing GFF/GTF files

```{r gff}
library(superintronic)
gff <- here::here("data-raw", "gencode.v27.annotation.gtf.gz")

# uncomment if no internet connection
# ref <- BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38 %>% 
#   get_genome_info() %>% 
#   GenomeInfoDb::keepStandardChromosomes("Homo sapiens", "coarse")

gr_gff <- read_gff(gff, genome_info = "hg38")
parts <- collect_parts(gr_gff)
parts
```

These can be interrogated as desired, but for our purposes we will keep
genes that are protein coding, on main chromosomes but not mitochondrial 
genome, and do not overlap any other genes and have more than one exon.

```{r default-filter}
parts_sub <- parts %>% 
  filter(
    gene_type == "protein_coding", 
    n_olaps == 1, 
    seqnames != "chrM",
    lengths(exonic_parts) > 1
  ) %>%
  GenomeInfoDb::keepStandardChromosomes("Homo sapiens", "coarse") %>% 
  GenomeInfoDb::dropSeqlevels("chrM", "coarse")

parts_sub
```


## Computing coverage over all replicates

Now we can take our BAM files and compute coverage. This
produces a large GRanges object, with two metadata columns,
`source` which is the BAM file  that coverage was computed for, and `score`
which is the coverage score. By default, this function computes
the coverage scores in parallel using BiocParallel.


```{r compute-coverage, cache = TRUE, dependson=design}
cvg <- compute_coverage_long(design, 
                             source = "File",
                             .which = get_genome_info(parts_sub),
                             .genome_info = get_genome_info(parts_sub),
                             .parallel = BiocParallel::MulticoreParam(4))

cvg
```

## Coverage over intronic/exonic regions

Now all the ingredients are in place to merge the coverage scores
to our prepared annotation with `join_parts()`. This again
returns a GRanges object, restricted to the intersection of the 
coverage ranges with intron/exon ranges. Additional columns are added
corresponding to the properties of the intron/exon.

```{r merge-annotations, eval = skip}
cvg_over_features <- join_parts(cvg, parts_sub)

cvg_over_features
```

Now we will compute summaries (rangenostics) for the polyA Kit to detect IR 
genes. This consists of three steps

1. Computing the average log-coverage over all exon/intron features:


```{r rangenostics-01}
polyA_features <- cvg_over_features %>% 
  plyranges::filter(Kit == "polyA") %>% 
  plyranges::select(-File)

# compute intron/exon features
res <- polyA_features %>% 
  mutate(log_score = log2(score + 0.5)) %>% 
  group_by(gene_id, feature_type) %>% 
  summarise(feature_average = Hmisc::wtd.mean(log_score, width),
            feature_sd = sqrt(Hmisc::wtd.var(log_score, width)),
            feature_length = sum(BiocGenerics::unique(feature_length)) * n_distinct(Replicate),
            score = score,
            n_bases = width,
            start = min(start),
            end = max(end),
            seqnames = unlist(BiocGenerics::unique(seqnames))
  ) %>% 
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE)
res
```


2. For exon features computing the mean and variance of average log-coverage 
   over all genes (lumpiness).
   
```{r rangenostics-02}
E_val <- res %>% 
  filter(feature_type == "exon") %>%
  filter(feature_sd > 0) %>% 
  summarise(
    E_mu = mean(feature_average),
    E_sigma = mean(feature_sd),
    E_raw = mean(sum(score*n_bases) / sum(n_bases))
  )
E_val

mcols(res) <- cbind(mcols(res), E_val)
```
   
   
3. Compute the average number of bases with a 
   log-coverage score above the E values defined above. We have also computed
   a smooth between over the intron/exon feature standard deviation against
   the average for visualisation purposes.

```{r rangenostics-03}
rango <- res %>% 
  mutate(
    n_bases_E_raw = sum(n_bases[score > E_raw]),
    prop_bases_E_raw = n_bases_E_raw / sum(n_bases)
  ) %>% 
  plyranges::select(-n_bases, -score, -seqnames, -start, -end, -width, -strand, 
         .drop_ranges = TRUE) %>% 
  dplyr::as_tibble() %>% 
  group_by(feature_type) %>% 
  tidyr::nest() %>% 
  mutate(
    smooth = lapply(data, function(x) {
      mgcv::gam(feature_sd ~ s(feature_average), data = x)
      }),
    augment = lapply(smooth, broom::augment),
  ) %>% 
  tidyr::unnest(data, augment) %>% 
  dplyr::select(-dplyr::ends_with("1"), -.sigma)
```

4. Plot the results.

We get very similar results to a `voom` plot in a standard limma analysis. We
have also overlaid on the E_mu and E_sigma values as potential cut-offs for
each feature. 

```{r voom-like-plot}
# rangenostics feature_average vs feature_sd coloured by n of bases above
# average raw exon coverage
ggplot(rango, aes(x = feature_average, 
                  y = feature_sd) +
  geom_point() +
  geom_line(aes(y = .fitted), colour = "blue") +
  geom_vline(aes(xintercept = E_mu), 
             data  = dplyr::distinct(rango, feature_type, E_mu)) +
  geom_hline(aes(yintercept = E_sigma),
             data = dplyr::distinct(rango, feature_type, E_sigma)) +
  facet_wrap(~feature_type) 
```

We also plot pairs of rangenositcs for each feature in a scatter plot matrix
(using a hexbin scatter plot). Again we get similar results to the plots
produced by a DE analysis.

```{r rangenostics-pairs}
all_features <- tidyr::gather(rango, "key", "value", 
                              -gene_id, -feature_type, -E_mu, -E_sigma) %>% 
  mutate(var = paste0(feature_type, "_", key)) %>% 
  plyranges::select(-feature_type, -key) %>% 
  arrange(gene_id) %>% 
  tidyr::spread(var, value)

all_features %>% 
  plyranges::select(gene_id, exon_feature_average, 
         intron_feature_average, intron_feature_sd, intron_n_bases_E_raw) %>% 
  GGally::ggpairs(columns = 2:5, lower = list(continuous = hex))
```

5. Decide on cut-off over each feature. It appears that choosing genes
with high intron feature standard deviations, and with number of bases above
E_mu in the 99th percentile discriminates intron retention features well.

```{r rangenositcs-hits}
hits <- all_features %>% 
  filter(exon_feature_average > E_mu, 
         intron_feature_sd > E_sigma, 
         intron_n_bases_E_raw > quantile(intron_n_bases_E_raw, 0.99)) %>% 
  group_by(gene_id)
hits
```

6. And show the coverage plots for the `nrow(hits)` genes.

```{r superintronic-coverage-plots}
hits %>% 
  dplyr::group_walk(save_plot)
```


##  IsoformSwitchAnalyzeR analysis

The Bioconductor package `IsoformSwitchAnalyzeR` also allows for the exploration
of intron retention events using a similar workflow:

1. import isoform quantifications from kallisto/salmon/other program of your choice.

We used kallisto quant on single read mode with an average fragment
size of 200 and a standard deviation of 20, on all fastq files for each
replicate in the polyA/total RNA kits. We need to use both here since 
IsoformSwitchAnalzyeR requires biological replicates for testing for
switching events.

```{r isf-prepare}
library(IsoformSwitchAnalyzeR)

quants <- importIsoformExpression(
  parentDir = here::here("data", "kallisto/"),
)

```


2. Preparing data structure called a `switchList` by importing annotations
and design matrix.

```{r isf-import}
# use a simplified version of the design
design_isf <- data.frame(sampleID = colnames(quants$abundance[,-1])) %>% 
  mutate(condition =  rep(c("polyA", "total-RNA"), 3),
         replicate = rep(c("R1", "R2", "R3"), each = 2)
  )

isf <- importRdata(
  isoformCountMatrix = quants$counts,
  isoformRepExpression = quants$abundance,
  designMatrix = design_isf,
  isoformExonAnnoation = here::here("data-raw", "gencode.v27.annotation.gtf.gz"),
  isoformNtFasta = here::here("data-raw", "gencode.v27.transcripts.fa.gz"),
  removeNonConvensionalChr = TRUE,
)

isf 
```


3. Filtering isoforms


Next we prefilter, the isoforms using roughly the same filters we used
in the superintronic analysis above. To speed things up we could further
specify a gene expression filter, but we have left that out for now.

```{r isf-filtered, cahce = TRUE, dependson=isf}
isf_filtered <- preFilter(isf,
                          acceptedGeneBiotype = "protein_coding",
                          removeSingleIsoformGenes = TRUE,
                          geneExpressionCutoff = 1,
                          isoformExpressionCutoff = 0.1,
                          keepIsoformInAllConditions = TRUE
                          )
isf_filtered
```

4. Searching for intron retention events

First we are required to run DEXSeq to test for isoform switching (
this does all pairwise comparisons between conditions, which slows things
down quite a bit.) and between the two kits. We have used quite a small
alpha since DEXSeq seems quite liberal...

```{r}
isf_analysed <- isoformSwitchTestDEXSeq(isf_filtered, 
                                        reduceToSwitchingGenes = TRUE,
                                        alpha = 0.01,
                                        dIFcutoff = 0.15)
isf_analysed
```


Now we can analyse intron retention events from one kit relative to another:

```{r isf-intron-retention, cache=TRUE}
# this takes quite a while to compute...
isf_analysed <- analyzeIntronRetention(isf_analysed)
isf_analysed <- analyzeSwitchConsequences(isf_analysed, "intron_retention")

# the result
isf_analysed

# isoforms with intron retention events
isf_analysed$switchConsequence %>% 
  dplyr::count(switchConsequence)
```

And the results can be summarised at the gene level and compared to the 
superintronic analysis. 

At the gene level there are around 502 genes declared significant
at 0.01 fdr cut-off between the polyA and total-RNA kits that
are filtered for intron retention events.

```{r top-table}
is_res <- extractTopSwitches(isf_analysed, 
                             filterForConsequences = TRUE, 
                             n = NA) %>% 
  dplyr::as_tibble()

is_res
```

We can also look at the coverage plots for these genes (we will choose
the top 20 genes):

```{r isf-coverage-plots}
is_res %>% 
  filter(Rank < 40) %>%
  group_by(gene_id) %>% 
  dplyr::group_walk(save_plot_isr)
```


Comparing to the previous analysis with superintronic, there is no
overlap between the two methods. (Of the genes in the IsoformSwitchAnalyzeR analysis, only
136 were kept by the filters in the superintronic, none of these were
selected by our rangenostics). The comparison to superintronic is not
quite the same since this method is based on isoforms within genes between 
kits rather
than our summaries over genes within just the polyA kit, 
however there still seems to be a lot of intron retention events by IsoformSwitchAnalyzeR.

```{r overlaps}
is_res <- is_res %>%
  dplyr::left_join(all_features %>% 
                     mutate(selected = gene_id %in% hits$gene_id) %>% 
                     dplyr::select(gene_id, selected))

dplyr::count(is_res, selected)
```